[{"content":"Immaginate un gioco per due giocatori basato su un mazzo standard di 52 carte, in cui ci interessa esclusivamente il colore delle carte: rosso (R) o nero (N).\nAll’inizio del gioco, ogni giocatore sceglie una sequenza di tre colori che osserverà per tutto il resto della partita. Ad esempio, il Giocatore 1 potrebbe scegliere la sequenza R-N-N, mentre il Giocatore 2 potrebbe optare per R-R-N.\nIl gioco procede quindi così: si pescano le carte una alla volta dal mazzo. Ogni volta che compare una sequenza corrispondente a quella di un giocatore, quel giocatore segna un punto e le carte vengono scartate. Si continua fino all’esaurimento del mazzo.\nA prima vista, il gioco sembra equo, ma esiste una strategia vincente per il secondo giocatore. La regola è semplice:\nIl Giocatore 2 osserva la sequenza scelta dal Giocatore 1, ad esempio R-N-R.\nCompone la propria sequenza seguendo questo schema:\nIl primo colore sarà l’inverso del colore centrale della sequenza avversaria (qui, R).\nIl secondo colore sarà uguale al primo della sequenza avversaria (qui, R).\nIl terzo colore sarà uguale al secondo della sequenza avversaria (qui, N).\nApplicando questa strategia, il Giocatore 2 aumenta le proprie possibilità di vincere. La domanda naturale è:\nQual è la probabilità che il Giocatore 2 vinca applicando questa strategia rispetto al Giocatore 1?\nClicca qui per la soluzione Il gioco descritto è un esempio classico noto come Penney\u0026rsquo;s Game. Si tratta di un gioco apparentemente equo, ma che in realtà favorisce nettamente il secondo giocatore.\nPer i più curiosi: Il gioco può essere schematizzato come una catena di Markov assorbente non omogenea, in cui:\nGli stati rappresentano le sequenze parziali già osservate.\nGli stati assorbenti corrispondono al completamento di una sequenza vincente.\nEsiste anche una spiegazione grafica e intuitiva di questo risultato. Consideriamo, ad esempio, la scelta del giocatore 1 NNN e quella del giocatore 2 RNN, limitando l’analisi alle prime quattro estrazioni.\nOsservando l’immagine sottostante, si nota che il giocatore 1 ha una possibilità concreta di vittoria solo entro le prime 3 estrazioni, evento rappresentato dal collegamento in $\\color{green}{verde}$. Questo è l’unico percorso che può portare alla comparsa della sua sequenza prima di quella dell’avversario.\nIn tutti gli altri casi, l’evoluzione del gioco conduce rapidamente verso stati che favoriscono il giocatore 2, evidenziati dai collegamenti in $\\color{red}{rosso}$. La struttura delle transizioni rende quindi il suo vantaggio sistematico, e non il risultato di una coincidenza. Probabilità di vittoria per ciascuna combinazione di sequenze Scelta del 1° giocatore Scelta del 2° giocatore Probabilità vittoria 1° giocatore Probabilità vittoria 2° giocatore Probabilità pareggio NNN NNN 0,11% 99,49% 0,40% NNR RNN 2,62% 93,54% 3,84% NRN NNR 11,61% 80,11% 8,28% NRR NNR 5,18% 88,29% 6,53% RNN RRN 5,18% 88,29% 6,53% RNR RRN 11,61% 80,11% 8,28% RRN NRR 2,62% 93,54% 3,84% RRR NRR 0,11% 99,49% 0,40% Nota: N = nero, R = rosso\nEffettuando 1 milione di simulazioni dove il giocatore-1 seleziona casualmente ogni volta la sua combinazione e il giocatore-2 implementa la sua strategia si ottiene il seguente risultato:\nProbabilità vittoria 1° giocatore Media Punti 1° giocatore Probabilità vittoria 2° giocatore Media Punti 2° giocatore Probabilità pareggio 4,88% 2,23±1,56 90,38% 6,09±1,39 0,40% Per completezza, allego di seguito il codice Python impiegato per la simulazione Monte Carlo dei risultati, dove si sono utilizzati 0 e 1 invece di N e R.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import random from random import randint as rng import math simulazioni = 1_000_000 l_meta_mazzo = 26 #metà della lunghezza del mazzo player1_scores = [] player2_scores = [] for _ in range(simulazioni): player1 = [rng(0,1),rng(0,1),rng(0,1)] player2 = [0 if player1[1] == 1 else 1, player1[0], player1[1]] mazzo = [1] * l_meta_mazzo + [0] * l_meta_mazzo random.shuffle(mazzo) player1_points = 0 player2_points = 0 i = 0 while i \u0026lt;= len(mazzo)-3: window = mazzo[i:i+3] if window == player1: player1_points += 1 i += 3 elif window == player2: player2_points += 1 i += 3 else: i += 1 player1_scores.append(player1_points) player2_scores.append(player2_points) # Calcolo percentuale di vittoria e media punti player1_wins = sum(1 for p1, p2 in zip(player1_scores, player2_scores) if p1 \u0026gt; p2) player2_wins = sum(1 for p1, p2 in zip(player1_scores, player2_scores) if p2 \u0026gt; p1) pareggi = simulazioni - player1_wins - player2_wins media_player1 = sum(player1_scores) / simulazioni media_player2 = sum(player2_scores) / simulazioni dev_std_player1 = math.sqrt(sum((x - media_player1) ** 2 for x in player1_scores) / simulazioni) dev_std_player2 = math.sqrt(sum((x - media_player2) ** 2 for x in player2_scores) / simulazioni) print(f\u0026#34;Player1 vince: {player1_wins / simulazioni * 100:.2f}%\u0026#34;) print(f\u0026#34;Player2 vince: {player2_wins / simulazioni * 100:.2f}%\u0026#34;) print(f\u0026#34;Pareggi: {pareggi / simulazioni * 100:.2f}%\u0026#34;) print(f\u0026#34;Media punti Player1: {media_player1:.2f}, Dev Std: {dev_std_player1:.2f}\u0026#34;) print(f\u0026#34;Media punti Player2: {media_player2:.2f}, Dev Std: {dev_std_player2:.2f}\u0026#34;) print(f\u0026#34;mazzo di {len(mazzo)} carte\u0026#34;) ","permalink":"https://lafleur977.github.io/ArVento/posts/art3/","summary":"\u003cp\u003eImmaginate un gioco per due giocatori basato su un mazzo standard di 52 carte, in cui ci interessa esclusivamente il \u003cstrong\u003ecolore\u003c/strong\u003e delle carte: rosso (R) o nero (N).\u003c/p\u003e\n\u003cp\u003eAll’inizio del gioco, ogni giocatore sceglie una \u003cstrong\u003esequenza di tre colori\u003c/strong\u003e che osserverà per tutto il resto della partita. Ad esempio, il \u003cstrong\u003eGiocatore 1\u003c/strong\u003e potrebbe scegliere la sequenza \u003cstrong\u003eR-N-N\u003c/strong\u003e, mentre il \u003cstrong\u003eGiocatore 2\u003c/strong\u003e potrebbe optare per \u003cstrong\u003eR-R-N\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eIl gioco procede quindi così: si pescano le carte una alla volta dal mazzo. Ogni volta che compare una sequenza corrispondente a quella di un giocatore, quel giocatore segna un punto e le carte vengono scartate. Si continua fino all’esaurimento del mazzo.\u003c/p\u003e","title":"Penney's Game"},{"content":"Tempo fa un amico mi ha proposto un problema di logica matematica davvero intrigante, e da allora non ho smesso di pensarci.\nImmaginate un esagono composto da celle esagonali più piccole, il cui lato misura 5 celle (come mostrato in figura).\nTutte le celle inizialmente sono spente e la regola per accenderle è semplice:\nUna cella si accende se e solo se è circondata da 3 celle già accese.\nLa domanda è:\nQual è il numero minimo di celle da accendere inizialmente e dove devono essere posizionate affinché dopo l\u0026rsquo;n-esima iterazione illumini tutte le celle?\nClicca qui per la soluzione Le soluzioni a questo quesito sono molteplici, e sopra ne ho mostrata una delle possibili.\nCiò che colpisce subito è il fatto che il numero minimo di celle necessario per illuminare l’intero esagono è 9.\nQuesto numero non è casuale: nasce dalla regola delle tre celle accese contigue. Ogni cella può accendersi solo se circondata da tre celle già illuminate, e da questa semplice regola emerge un vincolo geometrico più profondo: l’invariante del perimetro.\nIn altre parole, affinché una configurazione iniziale di celle accese sia realmente in grado di propagare la luce a tutto l’esagono, il perimetro calcolato dalle celle inizialmente accese deve coincidere con il perimetro dell’esagono grande.\nPer l’esagono in questione, il perimetro misura 54 lati. Solo accendendo 9 celle non contigue si riesce a ottenere questa corrispondenza (poiché ogni esagonino ha 6 lati e $9 \\cdot 6 = 54$).\nIn altre parole, la condizione necessaria e sufficiente affinché l’intero esagono si illumini è che la disposizione iniziale delle celle accese abbia un perimetro pari a quello dell’esagono grande. Il numero minimo di celle per soddisfare questa condizione è quindi 9, distribuite in modo da non essere contigue.\n","permalink":"https://lafleur977.github.io/ArVento/posts/art1/","summary":"\u003cp\u003eTempo fa un amico mi ha proposto un problema di logica matematica davvero intrigante, e da allora non ho smesso di pensarci.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eImmaginate un esagono composto da celle esagonali più piccole, il cui lato misura \u003cstrong\u003e5 celle\u003c/strong\u003e (come mostrato in figura).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"Immagine Griglia Esagonale non trovata\" loading=\"lazy\" src=\"/ArVento/posts/art1/posts/Art1/griglia_esagoni.png\"\u003e\u003c/p\u003e\n\u003cp\u003eTutte le celle inizialmente sono spente e la regola per accenderle è semplice:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUna cella si accende \u003cstrong\u003ese e solo se\u003c/strong\u003e è circondata da \u003cstrong\u003e3 celle già accese\u003c/strong\u003e.\u003c/p\u003e","title":"Il Problema degli esagoni"},{"content":"Negli anni ’60, nei laboratori di calcolo scientifico, un piccolo dettaglio algoritmico avrebbe cambiato il modo in cui gli studiosi guardano ai numeri casuali. Quel dettaglio si chiamava RANDU, uno dei generatori di numeri pseudocasuali più diffusi… e più problematici della storia.\nChe cos’è RANDU? RANDU è un generatore lineare congruenziale, un algoritmo che produce sequenze di numeri apparentemente casuali secondo la formula:\n$$X_{n+1} = (a \\cdot X_{n} + c) \\mod m$$\nNel caso specifico di RANDU, i parametri erano:\na=65539 m= $2^{31}$ c= 0 Questo algoritmo era incorporato nei computer IBM e utilizzato in simulazioni Monte Carlo in fisica, ingegneria e statistica. Appariva efficiente e “casuale” a prima vista, tanto da guadagnarsi la fiducia di intere generazioni di scienziati.\nMa arriviamo alla ragione dello scandalo, i numeri che generava avevano davvero un comportamento pseudo-casuale?\nEffettivamente se proviamo a generare un milione di numeri e facciamo l\u0026rsquo;istogramma, appare una distribuzione uniforme\u0026hellip;.\nProviamo a graficare in 3D i numeri generati da RANDU associandoli a triplette di punti cartesiani come in figura:\nAnche se proviamo a graficare i numeri generati da RANDU separandoli in triple successive di numeri generati, prendendo: $(X_n,X_{n+1},X_{n+2})$ come $(x,y,z)$ il comportamento potrebbe comunque apparire corretto\u0026hellip;\nInfatti sembrerebbe ancora essere frutto di una distribuzione uniforme\u0026hellip;\nMa attenzione\u0026hellip; Ruotando leggermente l\u0026rsquo;immagine ci viene rivelato il problema:\nIn uno spazio tridimensionale, i punti non si distribuiscono uniformemente come ci si aspetterebbe da una sequenza casuale, ma cadono su 15 piani distinti.\nQuesto fenomeno è dovuto a una scelta inadeguata dei parametri: la sequenza sembra casuale guardata singolarmente, ma le correlazioni tra numeri consecutivi introducono pattern regolari.\nIl difetto di RANDU ha avuto effetti concreti: simulazioni Monte Carlo che si basavano su di esso potevano fornire risultati distorti e falsamente coerenti. In altre parole, la scienza stava interpretando come casuale ciò che in realtà era strutturato e prevedibile.\nQuesto non è solo un curioso aneddoto storico. È diventato un caso di studio classico sull’importanza di verificare la qualità dei generatori di numeri pseudocasuali prima di usarli in applicazioni critiche. Anche oggi, quando si progettano algoritmi per simulazioni, crittografia o intelligenza artificiale, il principio rimane lo stesso: un numero casuale mal progettato può compromettere interi esperimenti.\n","permalink":"https://lafleur977.github.io/ArVento/posts/art2/","summary":"\u003cp\u003eNegli anni ’60, nei laboratori di calcolo scientifico, un piccolo dettaglio algoritmico avrebbe cambiato il modo in cui gli studiosi guardano ai numeri casuali. Quel dettaglio si chiamava \u003cstrong\u003eRANDU\u003c/strong\u003e, uno dei generatori di numeri pseudocasuali più diffusi… e più problematici della storia.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"che-cosè-randu\"\u003eChe cos’è RANDU?\u003c/h2\u003e\n\u003cp\u003eRANDU è un \u003ca href=\"https://it.wikipedia.org/wiki/Generatore_lineare_congruenziale\"\u003egeneratore lineare congruenziale\u003c/a\u003e, un algoritmo che produce sequenze di numeri apparentemente casuali secondo la formula:\u003c/p\u003e\n\u003cp\u003e$$X_{n+1} = (a \\cdot X_{n} + c) \\mod m$$\u003c/p\u003e","title":"Lo scandalo di RANDU"},{"content":"ArVento nasce come uno spazio deliberatamente libero, un luogo in cui le parole, sottratte a vincoli, titoli e investiture, possono dispiegarsi come pensieri in movimento, talvolta improvvisi, talvolta lungamente meditati, ma sempre autentici. Qui scrivo senza l’urgenza di convincere o piacere, con il solo intento di dare forma a ciò che penso, accettando che le idee mutino, devino o si contraddicano, proprio come il vento che le ispira. Questo spazio è mio, ma non chiuso: è aperto a chi legge con curiosità, riflette senza dogmi e riconosce nell’assenza di verità assolute una possibile forma di libertà.\n","permalink":"https://lafleur977.github.io/ArVento/about/","summary":"\u003cp\u003e\u003cstrong\u003eArVento\u003c/strong\u003e nasce come uno spazio deliberatamente libero, un luogo in cui le parole, sottratte a vincoli, titoli e investiture, possono dispiegarsi come pensieri in movimento, talvolta improvvisi, talvolta lungamente meditati, ma sempre autentici. Qui scrivo senza l’urgenza di convincere o piacere, con il solo intento di dare forma a ciò che penso, accettando che le idee mutino, devino o si contraddicano, proprio come il vento che le ispira. Questo spazio è mio, ma non chiuso: è aperto a chi legge con curiosità, riflette senza dogmi e riconosce nell’assenza di verità assolute una possibile forma di libertà.\u003c/p\u003e","title":""}]